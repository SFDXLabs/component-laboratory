/**
 * @description Controller for the Custom List View LWC component
 * Handles dynamic SOQL queries with field metadata retrieval
 * @author Generated by Claude
 */
public with sharing class CustomListViewController {
    
    /**
     * @description Wrapper class for returning query results with metadata
     */
    public class QueryResult {
        @AuraEnabled public List<SObject> records { get; set; }
        @AuraEnabled public Integer totalCount { get; set; }
        @AuraEnabled public Map<String, FieldMetadata> fieldMetadata { get; set; }
        @AuraEnabled public String errorMessage { get; set; }
        @AuraEnabled public Boolean success { get; set; }
    }
    
    /**
     * @description Wrapper class for field metadata information
     */
    public class FieldMetadata {
        @AuraEnabled public String label { get; set; }
        @AuraEnabled public String type { get; set; }
        @AuraEnabled public Boolean sortable { get; set; }
        @AuraEnabled public String relationshipName { get; set; }
        @AuraEnabled public Boolean isNameField { get; set; }
    }
    
    /**
     * @description Wrapper class for owner change operation results
     */
    public class OwnerChangeResult {
        @AuraEnabled public Boolean success { get; set; }
        @AuraEnabled public Integer successCount { get; set; }
        @AuraEnabled public Integer failureCount { get; set; }
        @AuraEnabled public String errorMessage { get; set; }
        @AuraEnabled public List<String> failedRecordIds { get; set; }
    }
    
    /**
     * @description Executes the SOQL query and returns results with metadata
     * @param soqlQuery The base SOQL query string
     * @param recordId Optional record ID to inject into query
     * @param searchTerm Optional search term for filtering
     * @param sortField Field to sort by
     * @param sortDirection ASC or DESC
     * @param pageSize Number of records per page
     * @param pageNumber Current page number (1-based)
     * @param filtersJson JSON string of field filters (e.g., {"Status__c":"Open","Priority__c":"High"})
     * @return QueryResult containing records, count, and metadata
     */
    @AuraEnabled(cacheable=false)
    public static QueryResult executeQuery(
        String soqlQuery,
        String recordId,
        String searchTerm,
        String sortField,
        String sortDirection,
        Integer pageSize,
        Integer pageNumber,
        String filtersJson
    ) {
        QueryResult result = new QueryResult();
        result.fieldMetadata = new Map<String, FieldMetadata>();
        result.success = true;
        
        try {
            // Validate inputs
            if (String.isBlank(soqlQuery)) {
                throw new AuraHandledException('SOQL query cannot be empty');
            }
            
            // Replace {recordId} placeholder if present
            if (String.isNotBlank(recordId)) {
                soqlQuery = soqlQuery.replace('{recordId}', '\'' + String.escapeSingleQuotes(recordId) + '\'');
            }
            
            // Replace {currentUserId} placeholder with the current user's ID
            if (soqlQuery.contains('{currentUserId}')) {
                soqlQuery = soqlQuery.replace('{currentUserId}', '\'' + UserInfo.getUserId() + '\'');
            }
            
            // Parse filters from JSON - now supports arrays for multi-select
            Map<String, List<String>> filters = new Map<String, List<String>>();
            if (String.isNotBlank(filtersJson)) {
                try {
                    Map<String, Object> parsedFilters = (Map<String, Object>) JSON.deserializeUntyped(filtersJson);
                    for (String key : parsedFilters.keySet()) {
                        Object val = parsedFilters.get(key);
                        if (val != null) {
                            List<String> values = new List<String>();
                            // Try to process as array first, fall back to single value
                            try {
                                List<Object> listVal = (List<Object>) val;
                                for (Object item : listVal) {
                                    if (item != null && String.isNotBlank(String.valueOf(item))) {
                                        values.add(String.valueOf(item));
                                    }
                                }
                            } catch (Exception castEx) {
                                // Not a list, treat as single value (backwards compatibility)
                                if (String.isNotBlank(String.valueOf(val))) {
                                    values.add(String.valueOf(val));
                                }
                            }
                            if (!values.isEmpty()) {
                                filters.put(key, values);
                            }
                        }
                    }
                } catch (Exception e) {
                    System.debug('Error parsing filters JSON: ' + e.getMessage());
                }
            }
            
            // Parse the query to extract object name and fields
            String objectName = extractObjectName(soqlQuery);
            List<String> queryFields = extractFields(soqlQuery);
            
            // Get field metadata for the queried fields
            result.fieldMetadata = getFieldMetadata(objectName, queryFields);
            
            // Build the complete query with sorting and pagination
            String countQuery = buildCountQuery(soqlQuery, searchTerm, queryFields, objectName, filters);
            String dataQuery = buildDataQuery(soqlQuery, searchTerm, queryFields, objectName, sortField, sortDirection, pageSize, pageNumber, filters);
            
            // Execute count query
            result.totalCount = Database.countQuery(countQuery);
            
            // Execute data query
            result.records = Database.query(dataQuery);
            
        } catch (Exception e) {
            result.success = false;
            result.errorMessage = e.getMessage();
            result.records = new List<SObject>();
            result.totalCount = 0;
        }
        
        return result;
    }
    
    /**
     * @description Searches for active users by name or email
     * @param searchTerm The search term to filter users
     * @return List of matching User records
     */
    @AuraEnabled(cacheable=false)
    public static List<User> searchUsers(String searchTerm) {
        if (String.isBlank(searchTerm) || searchTerm.length() < 2) {
            return new List<User>();
        }
        
        String searchPattern = '%' + String.escapeSingleQuotes(searchTerm) + '%';
        
        return [
            SELECT Id, Name, Email, SmallPhotoUrl, Title
            FROM User
            WHERE IsActive = true
            AND (Name LIKE :searchPattern OR Email LIKE :searchPattern)
            ORDER BY Name ASC
            LIMIT 20
        ];
    }
    
    /**
     * @description Changes the owner of multiple records
     * @param recordIds List of record IDs to update
     * @param newOwnerId The ID of the new owner
     * @return OwnerChangeResult with success/failure information
     */
    @AuraEnabled
    public static OwnerChangeResult changeRecordsOwner(List<String> recordIds, String newOwnerId) {
        OwnerChangeResult result = new OwnerChangeResult();
        result.failedRecordIds = new List<String>();
        result.successCount = 0;
        result.failureCount = 0;
        
        try {
            // Validate inputs
            if (recordIds == null || recordIds.isEmpty()) {
                throw new AuraHandledException('No records selected for owner change');
            }
            
            if (String.isBlank(newOwnerId)) {
                throw new AuraHandledException('New owner must be selected');
            }
            
            // Validate the new owner exists and is active
            List<User> newOwnerList = [
                SELECT Id, Name, IsActive 
                FROM User 
                WHERE Id = :newOwnerId 
                LIMIT 1
            ];
            
            if (newOwnerList.isEmpty()) {
                throw new AuraHandledException('Selected user not found');
            }
            
            if (!newOwnerList[0].IsActive) {
                throw new AuraHandledException('Selected user is not active');
            }
            
            // Determine the object type from the first record ID
            Id firstRecordId = Id.valueOf(recordIds[0]);
            String objectApiName = firstRecordId.getSObjectType().getDescribe().getName();
            
            // Check if the object has an OwnerId field
            Schema.SObjectType sObjectType = Schema.getGlobalDescribe().get(objectApiName);
            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();
            
            if (!fieldMap.containsKey('ownerid')) {
                throw new AuraHandledException('The selected object type does not support owner changes');
            }
            
            // Build and execute update
            List<SObject> recordsToUpdate = new List<SObject>();
            
            for (String recordId : recordIds) {
                SObject record = sObjectType.newSObject(Id.valueOf(recordId));
                record.put('OwnerId', newOwnerId);
                recordsToUpdate.add(record);
            }
            
            // Perform the update with partial success
            Database.SaveResult[] saveResults = Database.update(recordsToUpdate, false);
            
            for (Integer i = 0; i < saveResults.size(); i++) {
                if (saveResults[i].isSuccess()) {
                    result.successCount++;
                } else {
                    result.failureCount++;
                    result.failedRecordIds.add(recordIds[i]);
                    
                    // Capture first error message
                    if (String.isBlank(result.errorMessage)) {
                        for (Database.Error err : saveResults[i].getErrors()) {
                            result.errorMessage = err.getMessage();
                            break;
                        }
                    }
                }
            }
            
            result.success = result.failureCount == 0;
            
            if (result.failureCount > 0 && result.successCount > 0) {
                result.errorMessage = 'Partially successful. ' + result.successCount + ' record(s) updated, ' + 
                    result.failureCount + ' record(s) failed. First error: ' + result.errorMessage;
            }
            
        } catch (Exception e) {
            result.success = false;
            result.errorMessage = e.getMessage();
        }
        
        return result;
    }
    
    /**
     * @description Extracts the object name from the SOQL query
     */
    private static String extractObjectName(String soqlQuery) {
        Pattern p = Pattern.compile('(?i)FROM\\s+(\\w+)');
        Matcher m = p.matcher(soqlQuery);
        if (m.find()) {
            return m.group(1);
        }
        throw new AuraHandledException('Could not determine object name from query');
    }
    
    /**
     * @description Extracts field names from the SELECT clause
     */
    private static List<String> extractFields(String soqlQuery) {
        List<String> fields = new List<String>();
        Pattern p = Pattern.compile('(?i)SELECT\\s+(.+?)\\s+FROM');
        Matcher m = p.matcher(soqlQuery);
        
        if (m.find()) {
            String fieldsPart = m.group(1);
            for (String field : fieldsPart.split(',')) {
                String trimmedField = field.trim();
                // Handle relationship fields (e.g., Account.Name)
                if (trimmedField.contains('.')) {
                    fields.add(trimmedField);
                } else {
                    fields.add(trimmedField);
                }
            }
        }
        return fields;
    }
    
    /**
     * @description Gets metadata for the specified fields
     */
    private static Map<String, FieldMetadata> getFieldMetadata(String objectName, List<String> fields) {
        Map<String, FieldMetadata> metadata = new Map<String, FieldMetadata>();
        
        try {
            Schema.SObjectType sObjectType = Schema.getGlobalDescribe().get(objectName);
            if (sObjectType == null) {
                return metadata;
            }
            
            Schema.DescribeSObjectResult describeResult = sObjectType.getDescribe();
            Map<String, Schema.SObjectField> fieldMap = describeResult.fields.getMap();
            
            for (String fieldName : fields) {
                FieldMetadata fm = new FieldMetadata();
                fm.sortable = true;
                
                // Handle relationship fields
                if (fieldName.contains('.')) {
                    List<String> parts = fieldName.split('\\.');
                    String relationshipName = parts[0];
                    String relatedFieldName = parts[1];
                    
                    // Try to get the relationship field
                    String lookupFieldName = relationshipName;
                    if (relationshipName.endsWith('__r')) {
                        lookupFieldName = relationshipName.replace('__r', '__c');
                    } else {
                        lookupFieldName = relationshipName + 'Id';
                    }
                    
                    Schema.SObjectField lookupField = fieldMap.get(lookupFieldName.toLowerCase());
                    if (lookupField != null) {
                        Schema.DescribeFieldResult lookupDescribe = lookupField.getDescribe();
                        List<Schema.SObjectType> references = lookupDescribe.getReferenceTo();
                        if (!references.isEmpty()) {
                            Schema.DescribeSObjectResult relatedDescribe = references[0].getDescribe();
                            Map<String, Schema.SObjectField> relatedFieldMap = relatedDescribe.fields.getMap();
                            Schema.SObjectField relatedField = relatedFieldMap.get(relatedFieldName.toLowerCase());
                            if (relatedField != null) {
                                Schema.DescribeFieldResult relatedFieldDescribe = relatedField.getDescribe();
                                fm.label = relatedFieldDescribe.getLabel();
                                fm.type = String.valueOf(relatedFieldDescribe.getType());
                                fm.relationshipName = relationshipName;
                                fm.isNameField = relatedFieldDescribe.isNameField();
                            }
                        }
                    }
                    
                    if (fm.label == null) {
                        fm.label = fieldName;
                        fm.type = 'STRING';
                    }
                } else {
                    Schema.SObjectField field = fieldMap.get(fieldName.toLowerCase());
                    if (field != null) {
                        Schema.DescribeFieldResult fieldDescribe = field.getDescribe();
                        fm.label = fieldDescribe.getLabel();
                        fm.type = String.valueOf(fieldDescribe.getType());
                        fm.isNameField = fieldDescribe.isNameField();
                        
                        // Some field types are not sortable
                        if (fm.type == 'TEXTAREA' || fm.type == 'MULTIPICKLIST' || fm.type == 'LOCATION') {
                            fm.sortable = false;
                        }
                    } else {
                        fm.label = fieldName;
                        fm.type = 'STRING';
                    }
                }
                
                metadata.put(fieldName, fm);
            }
        } catch (Exception e) {
            System.debug('Error getting field metadata: ' + e.getMessage());
        }
        
        return metadata;
    }
    
    /**
     * @description Builds a count query from the original query
     */
    private static String buildCountQuery(String originalQuery, String searchTerm, List<String> fields, String objectName, Map<String, List<String>> filters) {
        // Extract the WHERE clause if present
        String whereClause = '';
        Pattern p = Pattern.compile('(?i)WHERE\\s+(.+?)(?:\\s+ORDER|\\s+LIMIT|\\s+OFFSET|$)');
        Matcher m = p.matcher(originalQuery);
        if (m.find()) {
            whereClause = m.group(1).trim();
        }
        
        // Add search term filter if provided
        if (String.isNotBlank(searchTerm)) {
            String searchFilter = buildSearchFilter(fields, searchTerm, objectName);
            if (String.isNotBlank(searchFilter)) {
                if (String.isNotBlank(whereClause)) {
                    whereClause = '(' + whereClause + ') AND (' + searchFilter + ')';
                } else {
                    whereClause = searchFilter;
                }
            }
        }
        
        // Add quick filters
        if (filters != null && !filters.isEmpty()) {
            String filterConditions = buildFilterConditions(filters);
            if (String.isNotBlank(filterConditions)) {
                if (String.isNotBlank(whereClause)) {
                    whereClause = '(' + whereClause + ') AND ' + filterConditions;
                } else {
                    whereClause = filterConditions;
                }
            }
        }
        
        String countQuery = 'SELECT COUNT() FROM ' + objectName;
        if (String.isNotBlank(whereClause)) {
            countQuery += ' WHERE ' + whereClause;
        }
        
        return countQuery;
    }
    
    /**
     * @description Builds the data query with sorting and pagination
     */
    private static String buildDataQuery(
        String originalQuery, 
        String searchTerm, 
        List<String> fields, 
        String objectName,
        String sortField,
        String sortDirection,
        Integer pageSize,
        Integer pageNumber,
        Map<String, List<String>> filters
    ) {
        // Extract SELECT fields
        String selectClause = 'SELECT ' + String.join(fields, ', ');
        
        // Ensure Id is always included
        if (!fields.contains('Id') && !fields.contains('id') && !fields.contains('ID')) {
            selectClause = 'SELECT Id, ' + String.join(fields, ', ');
        }
        
        // Extract WHERE clause
        String whereClause = '';
        Pattern p = Pattern.compile('(?i)WHERE\\s+(.+?)(?:\\s+ORDER|\\s+LIMIT|\\s+OFFSET|$)');
        Matcher m = p.matcher(originalQuery);
        if (m.find()) {
            whereClause = m.group(1).trim();
        }
        
        // Add search term filter if provided
        if (String.isNotBlank(searchTerm)) {
            String searchFilter = buildSearchFilter(fields, searchTerm, objectName);
            if (String.isNotBlank(searchFilter)) {
                if (String.isNotBlank(whereClause)) {
                    whereClause = '(' + whereClause + ') AND (' + searchFilter + ')';
                } else {
                    whereClause = searchFilter;
                }
            }
        }
        
        // Add quick filters
        if (filters != null && !filters.isEmpty()) {
            String filterConditions = buildFilterConditions(filters);
            if (String.isNotBlank(filterConditions)) {
                if (String.isNotBlank(whereClause)) {
                    whereClause = '(' + whereClause + ') AND ' + filterConditions;
                } else {
                    whereClause = filterConditions;
                }
            }
        }
        
        // Build the query
        String dataQuery = selectClause + ' FROM ' + objectName;
        if (String.isNotBlank(whereClause)) {
            dataQuery += ' WHERE ' + whereClause;
        }
        
        // Add ORDER BY
        if (String.isNotBlank(sortField)) {
            String direction = (sortDirection == 'DESC') ? 'DESC NULLS LAST' : 'ASC NULLS FIRST';
            dataQuery += ' ORDER BY ' + sortField + ' ' + direction;
        }
        
        // Add LIMIT and OFFSET for pagination
        Integer offset = (pageNumber - 1) * pageSize;
        dataQuery += ' LIMIT ' + pageSize + ' OFFSET ' + offset;
        
        return dataQuery;
    }
    
    /**
     * @description Builds filter conditions from the filters map (supports multi-select with IN clause)
     */
    private static String buildFilterConditions(Map<String, List<String>> filters) {
        List<String> conditions = new List<String>();
        
        for (String fieldName : filters.keySet()) {
            List<String> values = filters.get(fieldName);
            if (values != null && !values.isEmpty()) {
                if (values.size() == 1) {
                    // Single value - use equals
                    String escapedValue = String.escapeSingleQuotes(values[0]);
                    conditions.add(fieldName + ' = \'' + escapedValue + '\'');
                } else {
                    // Multiple values - use IN clause
                    List<String> escapedValues = new List<String>();
                    for (String val : values) {
                        escapedValues.add('\'' + String.escapeSingleQuotes(val) + '\'');
                    }
                    conditions.add(fieldName + ' IN (' + String.join(escapedValues, ', ') + ')');
                }
            }
        }
        
        return conditions.isEmpty() ? '' : String.join(conditions, ' AND ');
    }
    
    /**
     * @description Builds a search filter for text fields
     */
    private static String buildSearchFilter(List<String> fields, String searchTerm, String objectName) {
        List<String> conditions = new List<String>();
        String escapedTerm = '%' + String.escapeSingleQuotes(searchTerm) + '%';
        
        try {
            Schema.SObjectType sObjectType = Schema.getGlobalDescribe().get(objectName);
            Map<String, Schema.SObjectField> fieldMap = sObjectType.getDescribe().fields.getMap();
            
            for (String fieldName : fields) {
                // Skip relationship fields for search
                if (fieldName.contains('.')) continue;
                
                Schema.SObjectField field = fieldMap.get(fieldName.toLowerCase());
                if (field != null) {
                    Schema.DisplayType fieldType = field.getDescribe().getType();
                    // Only search on text-compatible fields
                    if (fieldType == Schema.DisplayType.STRING || 
                        fieldType == Schema.DisplayType.TEXTAREA ||
                        fieldType == Schema.DisplayType.EMAIL ||
                        fieldType == Schema.DisplayType.PHONE ||
                        fieldType == Schema.DisplayType.URL ||
                        fieldType == Schema.DisplayType.PICKLIST) {
                        conditions.add(fieldName + ' LIKE \'' + escapedTerm + '\'');
                    }
                }
            }
        } catch (Exception e) {
            System.debug('Error building search filter: ' + e.getMessage());
        }
        
        return conditions.isEmpty() ? '' : String.join(conditions, ' OR ');
    }
    
    /**
     * @description Gets the record URL for navigation
     * @param recordId The record ID
     * @return The relative URL to the record
     */
    @AuraEnabled(cacheable=true)
    public static String getRecordUrl(String recordId) {
        return '/' + recordId;
    }
}